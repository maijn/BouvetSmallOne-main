{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nimport { isBigint, isDate, isInfinite, isMap, isNaNValue, isRegExp, isSet, isUndefined, isSymbol, isArray, isError, isTypedArray, isURL } from './is';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\nimport { CustomTransformerRegistry } from './custom-transformer-registry';\nimport { allowedErrorProps } from './error-props';\nimport { findArr } from './util';\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\nvar simpleRules = [simpleTransformation(isUndefined, 'undefined', function () {\n  return null;\n}, function () {\n  return undefined;\n}), simpleTransformation(isBigint, 'bigint', function (v) {\n  return v.toString();\n}, function (v) {\n  if (typeof BigInt !== 'undefined') {\n    return BigInt(v);\n  }\n  console.error('Please add a BigInt polyfill.');\n  return v;\n}), simpleTransformation(isDate, 'Date', function (v) {\n  return v.toISOString();\n}, function (v) {\n  return new Date(v);\n}), simpleTransformation(isError, 'Error', function (v) {\n  var baseError = {\n    name: v.name,\n    message: v.message\n  };\n  allowedErrorProps.forEach(function (prop) {\n    baseError[prop] = v[prop];\n  });\n  return baseError;\n}, function (v) {\n  var e = new Error(v.message);\n  e.name = v.name;\n  e.stack = v.stack;\n  allowedErrorProps.forEach(function (prop) {\n    e[prop] = v[prop];\n  });\n  return e;\n}), simpleTransformation(isRegExp, 'regexp', function (v) {\n  return '' + v;\n}, function (regex) {\n  var body = regex.slice(1, regex.lastIndexOf('/'));\n  var flags = regex.slice(regex.lastIndexOf('/') + 1);\n  return new RegExp(body, flags);\n}), simpleTransformation(isSet, 'set',\n// (sets only exist in es6+)\n// eslint-disable-next-line es5/no-es6-methods\nfunction (v) {\n  return __spreadArray([], __read(v.values()));\n}, function (v) {\n  return new Set(v);\n}), simpleTransformation(isMap, 'map', function (v) {\n  return __spreadArray([], __read(v.entries()));\n}, function (v) {\n  return new Map(v);\n}), simpleTransformation(function (v) {\n  return isNaNValue(v) || isInfinite(v);\n}, 'number', function (v) {\n  if (isNaNValue(v)) {\n    return 'NaN';\n  }\n  if (v > 0) {\n    return 'Infinity';\n  } else {\n    return '-Infinity';\n  }\n}, Number), simpleTransformation(function (v) {\n  return v === 0 && 1 / v === -Infinity;\n}, 'number', function () {\n  return '-0';\n}, Number), simpleTransformation(isURL, 'URL', function (v) {\n  return v.toString();\n}, function (v) {\n  return new URL(v);\n})];\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\nvar symbolRule = compositeTransformation(function (s) {\n  if (isSymbol(s)) {\n    var isRegistered = !!SymbolRegistry.getIdentifier(s);\n    return isRegistered;\n  }\n  return false;\n}, function (s) {\n  var identifier = SymbolRegistry.getIdentifier(s);\n  return ['symbol', identifier];\n}, function (v) {\n  return v.description;\n}, function (_, a) {\n  var value = SymbolRegistry.getValue(a[1]);\n  if (!value) {\n    throw new Error('Trying to deserialize unknown symbol');\n  }\n  return value;\n});\nvar constructorToName = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Uint8ClampedArray].reduce(function (obj, ctor) {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\nvar typedArrayRule = compositeTransformation(isTypedArray, function (v) {\n  return ['typed-array', v.constructor.name];\n}, function (v) {\n  return __spreadArray([], __read(v));\n}, function (v, a) {\n  var ctor = constructorToName[a[1]];\n  if (!ctor) {\n    throw new Error('Trying to deserialize unknown typed array');\n  }\n  return new ctor(v);\n});\nexport function isInstanceOfRegisteredClass(potentialClass) {\n  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {\n    var isRegistered = !!ClassRegistry.getIdentifier(potentialClass.constructor);\n    return isRegistered;\n  }\n  return false;\n}\nvar classRule = compositeTransformation(isInstanceOfRegisteredClass, function (clazz) {\n  var identifier = ClassRegistry.getIdentifier(clazz.constructor);\n  return ['class', identifier];\n}, function (clazz) {\n  var allowedProps = ClassRegistry.getAllowedProps(clazz.constructor);\n  if (!allowedProps) {\n    return __assign({}, clazz);\n  }\n  var result = {};\n  allowedProps.forEach(function (prop) {\n    result[prop] = clazz[prop];\n  });\n  return result;\n}, function (v, a) {\n  var clazz = ClassRegistry.getValue(a[1]);\n  if (!clazz) {\n    throw new Error('Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564');\n  }\n  return Object.assign(Object.create(clazz.prototype), v);\n});\nvar customRule = compositeTransformation(function (value) {\n  return !!CustomTransformerRegistry.findApplicable(value);\n}, function (value) {\n  var transformer = CustomTransformerRegistry.findApplicable(value);\n  return ['custom', transformer.name];\n}, function (value) {\n  var transformer = CustomTransformerRegistry.findApplicable(value);\n  return transformer.serialize(value);\n}, function (v, a) {\n  var transformer = CustomTransformerRegistry.findByName(a[1]);\n  if (!transformer) {\n    throw new Error('Trying to deserialize unknown custom value');\n  }\n  return transformer.deserialize(v);\n});\nvar compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\nexport var transformValue = function (value) {\n  var applicableCompositeRule = findArr(compositeRules, function (rule) {\n    return rule.isApplicable(value);\n  });\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value),\n      type: applicableCompositeRule.annotation(value)\n    };\n  }\n  var applicableSimpleRule = findArr(simpleRules, function (rule) {\n    return rule.isApplicable(value);\n  });\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value),\n      type: applicableSimpleRule.annotation\n    };\n  }\n  return undefined;\n};\nvar simpleRulesByAnnotation = {};\nsimpleRules.forEach(function (rule) {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\nexport var untransformValue = function (json, type) {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type);\n      case 'class':\n        return classRule.untransform(json, type);\n      case 'custom':\n        return customRule.untransform(json, type);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    var transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n    return transformation.untransform(json);\n  }\n};","map":{"version":3,"mappings":"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","names":["isBigint","isDate","isInfinite","isMap","isNaNValue","isRegExp","isSet","isUndefined","isSymbol","isArray","isError","isTypedArray","isURL","ClassRegistry","SymbolRegistry","CustomTransformerRegistry","allowedErrorProps","findArr","simpleTransformation","isApplicable","annotation","transform","untransform","simpleRules","toString","BigInt","v","console","error","toISOString","Date","baseError","name","message","forEach","prop","e","Error","stack","body","regex","slice","lastIndexOf","flags","RegExp","values","Set","entries","Map","Number","Infinity","URL","compositeTransformation","symbolRule","s","isRegistered","getIdentifier","identifier","description","_","a","value","getValue","constructorToName","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Uint8ClampedArray","reduce","obj","ctor","typedArrayRule","constructor","isInstanceOfRegisteredClass","potentialClass","classRule","clazz","allowedProps","getAllowedProps","result","Object","assign","create","prototype","customRule","findApplicable","transformer","serialize","findByName","deserialize","compositeRules","transformValue","applicableCompositeRule","type","applicableSimpleRule","undefined","simpleRulesByAnnotation","rule","untransformValue","json","transformation"],"sources":["/Users/mai.nguyen/Desktop/Bouvet/FOREDRAG/BouvetSmallOne-main/node_modules/superjson/src/transformer.ts"],"sourcesContent":["import {\n  isBigint,\n  isDate,\n  isInfinite,\n  isMap,\n  isNaNValue,\n  isRegExp,\n  isSet,\n  isUndefined,\n  isSymbol,\n  isArray,\n  isError,\n  isTypedArray,\n  TypedArrayConstructor,\n  isURL,\n} from './is';\nimport { ClassRegistry } from './class-registry';\nimport { SymbolRegistry } from './symbol-registry';\nimport { CustomTransformerRegistry } from './custom-transformer-registry';\nimport { allowedErrorProps } from './error-props';\nimport { findArr } from './util';\n\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\n\ntype LeafTypeAnnotation =\n  | PrimitiveTypeAnnotation\n  | 'regexp'\n  | 'Date'\n  | 'Error'\n  | 'URL';\n\ntype TypedArrayAnnotation = ['typed-array', string];\ntype ClassTypeAnnotation = ['class', string];\ntype SymbolTypeAnnotation = ['symbol', string];\ntype CustomTypeAnnotation = ['custom', string];\n\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\n\ntype CompositeTypeAnnotation =\n  | TypedArrayAnnotation\n  | ClassTypeAnnotation\n  | SymbolTypeAnnotation\n  | CustomTypeAnnotation;\n\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\n\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: A,\n  transform: (v: I) => O,\n  untransform: (v: O) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst simpleRules = [\n  simpleTransformation(\n    isUndefined,\n    'undefined',\n    () => null,\n    () => undefined\n  ),\n  simpleTransformation(\n    isBigint,\n    'bigint',\n    v => v.toString(),\n    v => {\n      if (typeof BigInt !== 'undefined') {\n        return BigInt(v);\n      }\n\n      console.error('Please add a BigInt polyfill.');\n\n      return v as any;\n    }\n  ),\n  simpleTransformation(\n    isDate,\n    'Date',\n    v => v.toISOString(),\n    v => new Date(v)\n  ),\n\n  simpleTransformation(\n    isError,\n    'Error',\n    v => {\n      const baseError: any = {\n        name: v.name,\n        message: v.message,\n      };\n\n      allowedErrorProps.forEach(prop => {\n        baseError[prop] = (v as any)[prop];\n      });\n\n      return baseError;\n    },\n    v => {\n      const e = new Error(v.message);\n      e.name = v.name;\n      e.stack = v.stack;\n\n      allowedErrorProps.forEach(prop => {\n        (e as any)[prop] = v[prop];\n      });\n\n      return e;\n    }\n  ),\n\n  simpleTransformation(\n    isRegExp,\n    'regexp',\n    v => '' + v,\n    regex => {\n      const body = regex.slice(1, regex.lastIndexOf('/'));\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\n      return new RegExp(body, flags);\n    }\n  ),\n\n  simpleTransformation(\n    isSet,\n    'set',\n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    v => [...v.values()],\n    v => new Set(v)\n  ),\n  simpleTransformation(\n    isMap,\n    'map',\n    v => [...v.entries()],\n    v => new Map(v)\n  ),\n\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\n    (v): v is number => isNaNValue(v) || isInfinite(v),\n    'number',\n    v => {\n      if (isNaNValue(v)) {\n        return 'NaN';\n      }\n\n      if (v > 0) {\n        return 'Infinity';\n      } else {\n        return '-Infinity';\n      }\n    },\n    Number\n  ),\n\n  simpleTransformation<number, '-0', 'number'>(\n    (v): v is number => v === 0 && 1 / v === -Infinity,\n    'number',\n    () => {\n      return '-0';\n    },\n    Number\n  ),\n\n  simpleTransformation(\n    isURL,\n    'URL',\n    v => v.toString(),\n    v => new URL(v)\n  ),\n];\n\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\n  isApplicable: (v: any) => v is I,\n  annotation: (v: I) => A,\n  transform: (v: I) => O,\n  untransform: (v: O, a: A) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst symbolRule = compositeTransformation(\n  (s): s is Symbol => {\n    if (isSymbol(s)) {\n      const isRegistered = !!SymbolRegistry.getIdentifier(s);\n      return isRegistered;\n    }\n    return false;\n  },\n  s => {\n    const identifier = SymbolRegistry.getIdentifier(s);\n    return ['symbol', identifier!];\n  },\n  v => v.description,\n  (_, a) => {\n    const value = SymbolRegistry.getValue(a[1]);\n    if (!value) {\n      throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n  }\n);\n\nconst constructorToName = [\n  Int8Array,\n  Uint8Array,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  Uint8ClampedArray,\n].reduce<Record<string, TypedArrayConstructor>>((obj, ctor) => {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\n\nconst typedArrayRule = compositeTransformation(\n  isTypedArray,\n  v => ['typed-array', v.constructor.name],\n  v => [...v],\n  (v, a) => {\n    const ctor = constructorToName[a[1]];\n\n    if (!ctor) {\n      throw new Error('Trying to deserialize unknown typed array');\n    }\n\n    return new ctor(v);\n  }\n);\n\nexport function isInstanceOfRegisteredClass(\n  potentialClass: any\n): potentialClass is any {\n  if (potentialClass?.constructor) {\n    const isRegistered = !!ClassRegistry.getIdentifier(\n      potentialClass.constructor\n    );\n    return isRegistered;\n  }\n  return false;\n}\n\nconst classRule = compositeTransformation(\n  isInstanceOfRegisteredClass,\n  clazz => {\n    const identifier = ClassRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier!];\n  },\n  clazz => {\n    const allowedProps = ClassRegistry.getAllowedProps(clazz.constructor);\n    if (!allowedProps) {\n      return { ...clazz };\n    }\n\n    const result: any = {};\n    allowedProps.forEach(prop => {\n      result[prop] = clazz[prop];\n    });\n    return result;\n  },\n  (v, a) => {\n    const clazz = ClassRegistry.getValue(a[1]);\n\n    if (!clazz) {\n      throw new Error(\n        'Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564'\n      );\n    }\n\n    return Object.assign(Object.create(clazz.prototype), v);\n  }\n);\n\nconst customRule = compositeTransformation(\n  (value): value is any => {\n    return !!CustomTransformerRegistry.findApplicable(value);\n  },\n  value => {\n    const transformer = CustomTransformerRegistry.findApplicable(value)!;\n    return ['custom', transformer.name];\n  },\n  value => {\n    const transformer = CustomTransformerRegistry.findApplicable(value)!;\n    return transformer.serialize(value);\n  },\n  (v, a) => {\n    const transformer = CustomTransformerRegistry.findByName(a[1]);\n    if (!transformer) {\n      throw new Error('Trying to deserialize unknown custom value');\n    }\n    return transformer.deserialize(v);\n  }\n);\n\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\n\nexport const transformValue = (\n  value: any\n): { value: any; type: TypeAnnotation } | undefined => {\n  const applicableCompositeRule = findArr(compositeRules, rule =>\n    rule.isApplicable(value)\n  );\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value as never),\n      type: applicableCompositeRule.annotation(value),\n    };\n  }\n\n  const applicableSimpleRule = findArr(simpleRules, rule =>\n    rule.isApplicable(value)\n  );\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value as never),\n      type: applicableSimpleRule.annotation,\n    };\n  }\n\n  return undefined;\n};\n\nconst simpleRulesByAnnotation: Record<string, typeof simpleRules[0]> = {};\nsimpleRules.forEach(rule => {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\n\nexport const untransformValue = (json: any, type: TypeAnnotation) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type);\n      case 'class':\n        return classRule.untransform(json, type);\n      case 'custom':\n        return customRule.untransform(json, type);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json as never);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}