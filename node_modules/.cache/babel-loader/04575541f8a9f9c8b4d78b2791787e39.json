{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nimport { isArray, isEmptyObject, isMap, isPlainObject, isPrimitive, isSet } from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue } from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\nfunction traverse(tree, walker, origin) {\n  if (origin === void 0) {\n    origin = [];\n  }\n  if (!tree) {\n    return;\n  }\n  if (!isArray(tree)) {\n    forEach(tree, function (subtree, key) {\n      return traverse(subtree, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n    return;\n  }\n  var _a = __read(tree, 2),\n    nodeValue = _a[0],\n    children = _a[1];\n  if (children) {\n    forEach(children, function (child, key) {\n      traverse(child, walker, __spreadArray(__spreadArray([], __read(origin)), __read(parsePath(key))));\n    });\n  }\n  walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations) {\n  traverse(annotations, function (type, path) {\n    plain = setDeep(plain, path, function (v) {\n      return untransformValue(v, type);\n    });\n  });\n  return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations) {\n  function apply(identicalPaths, path) {\n    var object = getDeep(plain, parsePath(path));\n    identicalPaths.map(parsePath).forEach(function (identicalObjectPath) {\n      plain = setDeep(plain, identicalObjectPath, function () {\n        return object;\n      });\n    });\n  }\n  if (isArray(annotations)) {\n    var _a = __read(annotations, 2),\n      root = _a[0],\n      other = _a[1];\n    root.forEach(function (identicalPath) {\n      plain = setDeep(plain, parsePath(identicalPath), function () {\n        return plain;\n      });\n    });\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n  return plain;\n}\nvar isDeep = function (object) {\n  return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object);\n};\nfunction addIdentity(object, path, identities) {\n  var existingSet = identities.get(object);\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\nexport function generateReferentialEqualityAnnotations(identitites) {\n  var result = {};\n  var rootEqualityPaths = undefined;\n  identitites.forEach(function (paths) {\n    if (paths.length <= 1) {\n      return;\n    }\n    var _a = __read(paths.map(function (path) {\n        return path.map(String);\n      }).sort(function (a, b) {\n        return a.length - b.length;\n      })),\n      shortestPath = _a[0],\n      identicalPaths = _a.slice(1);\n    if (shortestPath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\n    }\n  });\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\nexport var walker = function (object, identities, path, objectsInThisPath) {\n  var _a;\n  if (path === void 0) {\n    path = [];\n  }\n  if (objectsInThisPath === void 0) {\n    objectsInThisPath = [];\n  }\n  if (!isPrimitive(object)) {\n    addIdentity(object, path, identities);\n  }\n  if (!isDeep(object)) {\n    var transformed_1 = transformValue(object);\n    if (transformed_1) {\n      return {\n        transformedValue: transformed_1.value,\n        annotations: [transformed_1.type]\n      };\n    } else {\n      return {\n        transformedValue: object\n      };\n    }\n  }\n  if (includes(objectsInThisPath, object)) {\n    return {\n      transformedValue: null\n    };\n  }\n  var transformationResult = transformValue(object);\n  var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;\n  if (!isPrimitive(object)) {\n    objectsInThisPath = __spreadArray(__spreadArray([], __read(objectsInThisPath)), [object]);\n  }\n  var transformedValue = isArray(transformed) ? [] : {};\n  var innerAnnotations = {};\n  forEach(transformed, function (value, index) {\n    var recursiveResult = walker(value, identities, __spreadArray(__spreadArray([], __read(path)), [index]), objectsInThisPath);\n    transformedValue[index] = recursiveResult.transformedValue;\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, function (tree, key) {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n  if (isEmptyObject(innerAnnotations)) {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type] : undefined\n    };\n  } else {\n    return {\n      transformedValue: transformedValue,\n      annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations\n    };\n  }\n};","map":{"version":3,"mappings":"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","names":["isArray","isEmptyObject","isMap","isPlainObject","isPrimitive","isSet","escapeKey","stringifyPath","isInstanceOfRegisteredClass","transformValue","untransformValue","includes","forEach","parsePath","getDeep","setDeep","traverse","tree","walker","origin","subtree","key","nodeValue","children","child","applyValueAnnotations","plain","annotations","type","path","v","applyReferentialEqualityAnnotations","apply","identicalPaths","object","map","identicalObjectPath","root","other","identicalPath","isDeep","addIdentity","identities","existingSet","get","push","set","generateReferentialEqualityAnnotations","identitites","result","rootEqualityPaths","undefined","paths","length","String","sort","a","b","shortestPath","objectsInThisPath","transformed_1","transformedValue","value","transformationResult","transformed","innerAnnotations","index","recursiveResult"],"sources":["/Users/mai.nguyen/Desktop/Bouvet/FOREDRAG/BouvetSmallOne-main/node_modules/superjson/src/plainer.ts"],"sourcesContent":["import {\n  isArray,\n  isEmptyObject,\n  isMap,\n  isPlainObject,\n  isPrimitive,\n  isSet,\n} from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport {\n  isInstanceOfRegisteredClass,\n  transformValue,\n  TypeAnnotation,\n  untransformValue,\n} from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\n\ntype Tree<T> = InnerNode<T> | Leaf<T>;\ntype Leaf<T> = [T];\ntype InnerNode<T> = [T, Record<string, Tree<T>>];\n\nexport type MinimisedTree<T> = Tree<T> | Record<string, Tree<T>> | undefined;\n\nfunction traverse<T>(\n  tree: MinimisedTree<T>,\n  walker: (v: T, path: string[]) => void,\n  origin: string[] = []\n): void {\n  if (!tree) {\n    return;\n  }\n\n  if (!isArray(tree)) {\n    forEach(tree, (subtree, key) =>\n      traverse(subtree, walker, [...origin, ...parsePath(key)])\n    );\n    return;\n  }\n\n  const [nodeValue, children] = tree;\n  if (children) {\n    forEach(children, (child, key) => {\n      traverse(child, walker, [...origin, ...parsePath(key)]);\n    });\n  }\n\n  walker(nodeValue, origin);\n}\n\nexport function applyValueAnnotations(\n  plain: any,\n  annotations: MinimisedTree<TypeAnnotation>\n) {\n  traverse(annotations, (type, path) => {\n    plain = setDeep(plain, path, v => untransformValue(v, type));\n  });\n\n  return plain;\n}\n\nexport function applyReferentialEqualityAnnotations(\n  plain: any,\n  annotations: ReferentialEqualityAnnotations\n) {\n  function apply(identicalPaths: string[], path: string) {\n    const object = getDeep(plain, parsePath(path));\n\n    identicalPaths.map(parsePath).forEach(identicalObjectPath => {\n      plain = setDeep(plain, identicalObjectPath, () => object);\n    });\n  }\n\n  if (isArray(annotations)) {\n    const [root, other] = annotations;\n    root.forEach(identicalPath => {\n      plain = setDeep(plain, parsePath(identicalPath), () => plain);\n    });\n\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n\n  return plain;\n}\n\nconst isDeep = (object: any): boolean =>\n  isPlainObject(object) ||\n  isArray(object) ||\n  isMap(object) ||\n  isSet(object) ||\n  isInstanceOfRegisteredClass(object);\n\nfunction addIdentity(object: any, path: any[], identities: Map<any, any[][]>) {\n  const existingSet = identities.get(object);\n\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\n\ninterface Result {\n  transformedValue: any;\n  annotations?: MinimisedTree<TypeAnnotation>;\n}\n\nexport type ReferentialEqualityAnnotations =\n  | Record<string, string[]>\n  | [string[]]\n  | [string[], Record<string, string[]>];\n\nexport function generateReferentialEqualityAnnotations(\n  identitites: Map<any, any[][]>\n): ReferentialEqualityAnnotations | undefined {\n  const result: Record<string, string[]> = {};\n  let rootEqualityPaths: string[] | undefined = undefined;\n\n  identitites.forEach(paths => {\n    if (paths.length <= 1) {\n      return;\n    }\n\n    const [shortestPath, ...identicalPaths] = paths\n      .map(path => path.map(String))\n      .sort((a, b) => a.length - b.length);\n\n    if (shortestPath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);\n    }\n  });\n\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\n\nexport const walker = (\n  object: any,\n  identities: Map<any, any[][]>,\n  path: any[] = [],\n  objectsInThisPath: any[] = []\n): Result => {\n  if (!isPrimitive(object)) {\n    addIdentity(object, path, identities);\n  }\n\n  if (!isDeep(object)) {\n    const transformed = transformValue(object);\n    if (transformed) {\n      return {\n        transformedValue: transformed.value,\n        annotations: [transformed.type],\n      };\n    } else {\n      return {\n        transformedValue: object,\n      };\n    }\n  }\n\n  if (includes(objectsInThisPath, object)) {\n    return {\n      transformedValue: null,\n    };\n  }\n\n  const transformationResult = transformValue(object);\n  const transformed = transformationResult?.value ?? object;\n\n  if (!isPrimitive(object)) {\n    objectsInThisPath = [...objectsInThisPath, object];\n  }\n\n  const transformedValue: any = isArray(transformed) ? [] : {};\n  const innerAnnotations: Record<string, Tree<TypeAnnotation>> = {};\n\n  forEach(transformed, (value, index) => {\n    const recursiveResult = walker(\n      value,\n      identities,\n      [...path, index],\n      objectsInThisPath\n    );\n\n    transformedValue[index] = recursiveResult.transformedValue;\n\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, (tree, key) => {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n\n  if (isEmptyObject(innerAnnotations)) {\n    return {\n      transformedValue,\n      annotations: !!transformationResult\n        ? [transformationResult.type]\n        : undefined,\n    };\n  } else {\n    return {\n      transformedValue,\n      annotations: !!transformationResult\n        ? [transformationResult.type, innerAnnotations]\n        : innerAnnotations,\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}